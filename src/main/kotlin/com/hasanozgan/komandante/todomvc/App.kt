/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.hasanozgan.komandante.todomvc

import com.hasanozgan.komandante.AggregateHandler
import com.hasanozgan.komandante.commandbus.newCommandBus
import com.hasanozgan.komandante.eventbus.newEventBus
import com.hasanozgan.komandante.eventhandler.ProjectorEventHandler
import com.hasanozgan.komandante.eventstore.exposed.dao.Events
import com.hasanozgan.komandante.eventstore.newEventStoreWithExposedAdapter
import com.hasanozgan.komandante.messagebus.newMessageBusWithLocalAdapter
import com.hasanozgan.komandante.newAggregateID
import com.hasanozgan.komandante.todomvc.domain.*
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.aggregateID
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.createdAt
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.updatedAt
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.version
import io.ktor.application.Application
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.features.CallLogging
import io.ktor.features.ContentNegotiation
import io.ktor.features.DefaultHeaders
import io.ktor.gson.gson
import io.ktor.http.cio.websocket.Frame
import io.ktor.http.content.default
import io.ktor.http.content.file
import io.ktor.http.content.static
import io.ktor.http.content.staticRootFolder
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.response.respondText
import io.ktor.routing.get
import io.ktor.routing.post
import io.ktor.routing.routing
import io.ktor.server.netty.EngineMain
import io.ktor.websocket.WebSockets
import io.ktor.websocket.webSocket
import kotlinx.coroutines.channels.ClosedReceiveChannelException
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SchemaUtils
import org.jetbrains.exposed.sql.select
import org.jetbrains.exposed.sql.transactions.transaction
import java.io.File
import java.time.Duration
import java.util.*

data class AddItemRequest(val id: TodoListID, val desc: String)
data class RemoveItemRequest(val id: TodoListID, val item_id: TodoItemID)
data class SetItemDescriptionRequest(val id: TodoListID, val item_id: TodoItemID, val desc: String)
data class CheckItemRequest(val id: TodoListID, val item_id: TodoItemID, val checked: Boolean)
data class CheckAllItemsRequest(val id: TodoListID, val checked: Boolean)

fun main(args: Array<String>): Unit = EngineMain.main(args)

fun Application.main() {

    // CQRS / ES Setup
    val todoListID = newAggregateID()
    val messageBus = newMessageBusWithLocalAdapter()
    val commandBus = newCommandBus(messageBus)
    val eventBus = newEventBus(messageBus)
    val eventStore = newEventStoreWithExposedAdapter()
    val aggregateHandler = AggregateHandler(eventStore, eventBus)
    Database.connect(url = "jdbc:h2:mem:todolist;DB_CLOSE_DELAY=-1", driver = "org.h2.Driver")

    transaction {
        SchemaUtils.create(Events, TodoRepo, TodoItemRepo)
        commit()
    }

    // CQRS Setup
    commandBus.registerAggregate(aggregateHandler, TodoListAggregateFactory())
    commandBus.subscribe<TodoListCommand> {
        println("COMMAND RECEIVEDs: ${it}")
    }

    val todoListProjector = TodoListProjector()
    val projectorEventHandler = ProjectorEventHandler(todoListProjector, commandBus)
    eventBus.addHandler(projectorEventHandler)

    val eventReceiver = mutableListOf<String>()
    eventBus.subscribe<TodoListEvent> {
        println("EVENT RECEIVED: ${it}")
        eventReceiver.add(it.toString())
    }

    commandBus.publish(CreateCommand(todoListID))

    install(DefaultHeaders)
    install(CallLogging)
    install(WebSockets) {
        pingPeriod = Duration.ofSeconds(1)
        timeout = Duration.ofSeconds(1)
        maxFrameSize = Long.MAX_VALUE
        masking = false
    }
    install(ContentNegotiation) {
        gson {
            setPrettyPrinting()
        }
    }

    routing {

        webSocket("/api/events") {
            try {
                // FIXME: This is not thread safe
                if (eventReceiver.isNotEmpty()) {
                    println("message received")
                    outgoing.send(Frame.Text("Some Message"))
                    eventReceiver.clear()
                }
                outgoing.send(Frame.Ping("ping".toByteArray()))
            } catch (e: ClosedReceiveChannelException) {
                println("onClose ${closeReason.await()}")
            } catch (e: Throwable) {
                println("onError ${closeReason.await()}")
                e.printStackTrace()
            }
        }

        static("/") {
            staticRootFolder = File("ui")
            file("elm.js")
            file("styles.css")
            default("index.html")
        }

        post("/api/todos/create") {
            commandBus.publish(CreateCommand(todoListID))
            call.respondText("{}")
        }
        post("/api/todos/delete") {
            commandBus.publish(DeleteCommand(todoListID))
            call.respondText("{}")
        }
        post("/api/todos/add_item") {
            val req = call.receive<AddItemRequest>()
            commandBus.publish(AddItemCommand(req.id, req.desc))
            call.respondText("{}")
        }
        post("/api/todos/remove_item") {
            val req = call.receive<RemoveItemRequest>()
            commandBus.publish(RemoveItemCommand(req.id, req.item_id))
            call.respondText("{}")
        }
        post("/api/todos/remove_completed") {
            commandBus.publish(RemoveCompletedItemsCommand(todoListID))
            call.respondText("{}")
        }
        post("/api/todos/set_item_desc") {
            val req = call.receive<SetItemDescriptionRequest>()
            commandBus.publish(SetItemDescriptionCommand(req.id, req.item_id, req.desc))
            call.respondText("{}")
        }
        post("/api/todos/check_item") {
            val req = call.receive<CheckItemRequest>()
            commandBus.publish(CheckItemCommand(req.id, req.item_id, req.checked))
            call.respondText("{}")
        }
        post("/api/todos/check_all_items") {
            val req = call.receive<CheckAllItemsRequest>()
            commandBus.publish(CheckAllItemsCommand(req.id, req.checked))
            call.respondText("{}")
        }

        get("/api/todos") {
            val todolist = transaction {
                val todoItems = TodoRepo.innerJoin(TodoItemRepo)
                        .select { TodoRepo.aggregateID.eq(todoListID) }
                        .map { mapTodoItemDto(it) }
                        .toList()

                TodoRepo.select { TodoRepo.aggregateID.eq(todoListID) }.map {
                    TodoDto(it[aggregateID], it[version], it[createdAt].toString("yyyy-MM-dd"), it[updatedAt].toString("yyyy-MM-dd"), todoItems)
                }.toList()
            }

            call.respond(todolist)
        }
    }
}


data class TodoItemDto(val id: Int, val desc: String, val completed: Boolean)
data class TodoDto(val id: UUID, val version: Int, val created_at: String, val updated_at: String, val items: List<TodoItemDto>)

fun mapTodoItemDto(it: ResultRow): TodoItemDto {
    return TodoItemDto(it[TodoItemRepo.index], it[TodoItemRepo.description], it[TodoItemRepo.completed])
}