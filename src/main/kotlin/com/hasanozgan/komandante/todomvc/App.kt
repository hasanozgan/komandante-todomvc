/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.hasanozgan.komandante.todomvc

import com.hasanozgan.komandante.AggregateHandler
import com.hasanozgan.komandante.commandbus.newCommandBus
import com.hasanozgan.komandante.eventbus.newEventBus
import com.hasanozgan.komandante.eventhandler.ProjectorEventHandler
import com.hasanozgan.komandante.eventstore.exposed.dao.Events
import com.hasanozgan.komandante.eventstore.newEventStoreWithExposedAdapter
import com.hasanozgan.komandante.messagebus.newMessageBusWithLocalAdapter
import com.hasanozgan.komandante.newAggregateID
import com.hasanozgan.komandante.todomvc.domain.*
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.aggregateID
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.createdAt
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.updatedAt
import com.hasanozgan.komandante.todomvc.domain.TodoRepo.version
import io.ktor.application.Application
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.features.CallLogging
import io.ktor.features.ContentNegotiation
import io.ktor.features.DefaultHeaders
import io.ktor.gson.gson
import io.ktor.http.cio.websocket.Frame
import io.ktor.http.content.default
import io.ktor.http.content.file
import io.ktor.http.content.static
import io.ktor.http.content.staticRootFolder
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.response.respondText
import io.ktor.routing.get
import io.ktor.routing.post
import io.ktor.routing.routing
import io.ktor.server.netty.EngineMain
import io.ktor.websocket.WebSockets
import io.ktor.websocket.webSocket
import kotlinx.coroutines.channels.ClosedReceiveChannelException
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SchemaUtils
import org.jetbrains.exposed.sql.select
import org.jetbrains.exposed.sql.transactions.transaction
import java.io.File
import java.time.Duration
import java.util.*

//class EventBus {
//
//    private val channel = BroadcastChannel<Any>(1)
//
//    fun send(event: Any, context: CoroutineContext = Dispatchers.Main) {
//
//        GlobalScope.launch(context) {
//            channel.send(event)
//        }
//    }
//
//    fun subscribe(): ReceiveChannel<Any> =
//            channel.openSubscription()
//
//    inline fun <reified T> subscribeToEvent() =
//            subscribe().filter { it is T }.map { it as T }
//}

//TODO: Items
// 1) Replace TODOMVC app with react sample
// 2) Replaced websocket with sse
// 3) Replace RxJava.Publisher with BroadcastChannel ?

data class AddItem(val id: TodoListID, val desc: String)

fun main(args: Array<String>): Unit = EngineMain.main(args)

fun Application.main() {
    install(DefaultHeaders)
    install(CallLogging)
    install(WebSockets) {
        pingPeriod = Duration.ofSeconds(1)
        timeout = Duration.ofSeconds(1)
        maxFrameSize = Long.MAX_VALUE
        masking = false
    }
    install(ContentNegotiation) {
        gson {
            setPrettyPrinting()
        }
    }

    routing {
        // CQRS / ES Setup
        val todoListID = newAggregateID()
        val messageBus = newMessageBusWithLocalAdapter()
        val commandBus = newCommandBus(messageBus)
        val eventBus = newEventBus(messageBus)
        val eventStore = newEventStoreWithExposedAdapter()
        val aggregateHandler = AggregateHandler(eventStore, eventBus)
        Database.connect(url = "jdbc:h2:mem:todolist;DB_CLOSE_DELAY=-1", driver = "org.h2.Driver")

        transaction {
            SchemaUtils.create(Events, TodoRepo, TodoItemRepo)
            commit()
        }

        // CQRS Setup
        commandBus.registerAggregate(aggregateHandler, TodoListAggregateFactory())
        commandBus.subscribe<TodoListCommand> {
            println("COMMAND RECEIVEDs: ${it}")
        }

        val todoListProjector = TodoListProjector()
        val projectorEventHandler = ProjectorEventHandler(todoListProjector, commandBus)
        eventBus.addHandler(projectorEventHandler)

        val eventReceiver = mutableListOf<String>()
        eventBus.subscribe<TodoListEvent> {
            println("EVENT RECEIVED: ${it}")
            eventReceiver.add(it.toString())
        }

        commandBus.publish(CreateCommand(todoListID))

        webSocket("/api/events") {
            try {
                // FIXME: This is not thread safe
                if (eventReceiver.isNotEmpty()) {
                    println("message received")
                    outgoing.send(Frame.Text("Some Message"))
                    eventReceiver.clear()
                }
                outgoing.send(Frame.Ping("ping".toByteArray()))
            } catch (e: ClosedReceiveChannelException) {
                println("onClose ${closeReason.await()}")
            } catch (e: Throwable) {
                println("onError ${closeReason.await()}")
                e.printStackTrace()
            }
        }

        static("/") {
            staticRootFolder = File("ui")
            file("elm.js")
            file("styles.css")
            default("index.html")
        }

        post("/api/todos/create") {
            commandBus.publish(CreateCommand(todoListID))
            call.respondText("{}")
        }
        post("/api/todos/delete") {
            call.respondText("{}")
        }
        post("/api/todos/add_item") {
            val addItemREq = call.receive<AddItem>()
            commandBus.publish(AddItemCommand(addItemREq.id, addItemREq.desc))
            call.respondText("{}")
        }
        post("/api/todos/remove_item") {
            call.respondText("{}")
        }
        post("/api/todos/remove_completed") {
            call.respondText("{}")
        }
        post("/api/todos/set_item_desc") {
            call.respondText("{}")
        }
        post("/api/todos/check_item") {
            call.respondText("{}")
        }
        post("/api/todos/check_all_items") {
            call.respondText("{}")
        }

        get("/api/todos") {
            val todolist = transaction {
                val todoItems = TodoRepo.innerJoin(TodoItemRepo)
                        .select { TodoRepo.aggregateID.eq(todoListID) }
                        .map { mapTodoItemDto(it) }
                        .toList()

                TodoRepo.select { TodoRepo.aggregateID.eq(todoListID) }.map {
                    TodoDto(it[aggregateID], it[version], it[createdAt].toString("yyyy-MM-dd"), it[updatedAt].toString("yyyy-MM-dd"), todoItems)
                }.toList()
            }

            call.respond(todolist)
        }
    }
}


data class TodoItemDto(val id: Int, val desc: String, val completed: Boolean)
data class TodoDto(val id: UUID, val version: Int, val created_at: String, val updated_at: String, val items: List<TodoItemDto>)

fun mapTodoItemDto(it: ResultRow): TodoItemDto {
    return TodoItemDto(it[TodoItemRepo.index], it[TodoItemRepo.description], it[TodoItemRepo.completed])
}